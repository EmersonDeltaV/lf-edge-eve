// Copyright (c) 2017-2018 Zededa, Inc.
// SPDX-License-Identifier: Apache-2.0

// dnsmasq configlets for overlay and underlay interfaces towards domU

package zedrouter

import (
	"bufio"
	"fmt"
	"io"
	"io/ioutil"
	"net"
	"os"
	"strconv"
	"strings"
	"syscall"
	"time"

	"github.com/google/go-cmp/cmp"
	"github.com/lf-edge/eve/pkg/pillar/base"
	"github.com/lf-edge/eve/pkg/pillar/types"
	"github.com/lf-edge/eve/pkg/pillar/utils"
	"github.com/sirupsen/logrus"
)

// XXX inotify seems to stop reporting any changes in some cases
// XXX avoid by start and stop dnsmasq when we add entries
// XXX KALYAN - We need to set this to have DHCP working with Network instances.
//
//	Turning this flag on temporarily till we figure out what's happening.
const dnsmasqStopStart = false // XXX change? remove?

const dnsmasqStatic = `
# Automatically generated by zedrouter
except-interface=lo
bind-interfaces
quiet-dhcp
quiet-dhcp6
no-hosts
no-ping
bogus-priv
neg-ttl=10
dhcp-ttl=600
`

// dnsmasqLeaseDir is used to for the leases
// of bridgeNames
var dnsmasqLeaseDir = runDirname + "/dnsmasq.leases/"

// dnsmasqLeasePath provides a unique file
// We traverse the dnsmasqLeaseDir directory to get the list of bridgeNames
func dnsmasqLeasePath(bridgeName string) string {
	leasePathname := dnsmasqLeaseDir + "/" + bridgeName
	return leasePathname
}

func dnsmasqBridgeNames() []string {
	var bridgeNames []string

	locations, err := ioutil.ReadDir(dnsmasqLeaseDir)
	if err != nil {
		log.Error(err)
		return bridgeNames
	}

	for _, location := range locations {
		bridgeNames = append(bridgeNames, location.Name())
	}
	return bridgeNames
}

func dnsmasqInitDirs() {
	if _, err := os.Stat(dnsmasqLeaseDir); err != nil {
		log.Functionf("Create %s\n", dnsmasqLeaseDir)
		if err := os.Mkdir(dnsmasqLeaseDir, 0755); err != nil {
			log.Fatal(err)
		}
	} else {
		// dnsmasq needs to read as nobody
		if err := os.Chmod(dnsmasqLeaseDir, 0755); err != nil {
			log.Fatal(err)
		}
	}
}

func dnsmasqClearLeases() {
	leasesFile := "/var/lib/misc/dnsmasq.leases"
	if _, err := os.Stat(leasesFile); err == nil {
		if err := os.Remove(leasesFile); err != nil {
			log.Fatal(err)
		}
	}
}

func dnsmasqConfigFile(bridgeName string) string {
	cfgFilename := "dnsmasq." + bridgeName + ".conf"
	return cfgFilename
}

func dnsmasqConfigPath(bridgeName string) string {
	cfgFilename := dnsmasqConfigFile(bridgeName)
	cfgPathname := runDirname + "/" + cfgFilename
	return cfgPathname
}

func dnsmasqDhcpHostDir(bridgeName string) string {
	dhcphostsDir := runDirname + "/dhcp-hosts." + bridgeName
	return dhcphostsDir
}

// createDnsmasqConfiglet
// When we create a linux bridge we set this up
// Also called when we need to update the ipsets
func createDnsmasqConfiglet(
	ctx *zedrouterContext,
	bridgeName string, bridgeIPAddr string,
	netstatus *types.NetworkInstanceStatus, hostsDir string,
	ipsetHosts []string, uplink string,
	dnsServers []net.IP, ntpServers []net.IP) {

	log.Functionf("createDnsmasqConfiglet(%s, %s) netstatus %v, ipsetHosts %v uplink %s dnsServers %v ntpServers %v",
		bridgeName, bridgeIPAddr, netstatus, ipsetHosts, uplink, dnsServers, ntpServers)

	cfgPathname := dnsmasqConfigPath(bridgeName)
	// Delete if it exists
	if _, err := os.Stat(cfgPathname); err == nil {
		if err := os.Remove(cfgPathname); err != nil {
			errStr := fmt.Sprintf("createDnsmasqConfiglet %v",
				err)
			log.Errorln(errStr)
		}
	}
	file, err := os.Create(cfgPathname)
	if err != nil {
		log.Fatal("createDnsmasqConfiglet failed ", err)
	}
	defer file.Close()

	// Create a dhcp-hosts directory to be used when hosts are added
	dhcphostsDir := dnsmasqDhcpHostDir(bridgeName)
	ensureDir(dhcphostsDir)

	file.WriteString(dnsmasqStatic)

	// XXX look at zedrouter loglevel; perhaps we should introduce a
	// separate logger for dnsmasq or per bridge to have more fine-grained
	// control
	switch logger.GetLevel() {
	case logrus.TraceLevel:
		file.WriteString("log-queries\n")
		file.WriteString("log-dhcp\n")
	case logrus.DebugLevel:
		file.WriteString("log-dhcp\n")
	}

	file.WriteString(fmt.Sprintf("dhcp-leasefile=%s\n",
		dnsmasqLeasePath(bridgeName)))

	// Pick file where dnsmasq should send DNS read upstream
	// If we have no uplink for this network instance that is nowhere
	// If we have an uplink but no dnsServers for it, then we let
	// dnsmasq use the host's /etc/resolv.conf
	if uplink == "" {
		file.WriteString("no-resolv\n")
	} else if len(dnsServers) != 0 {
		for _, s := range dnsServers {
			file.WriteString(fmt.Sprintf("server=%s@%s\n", s, uplink))
		}
		file.WriteString("no-resolv\n")
	}

	for _, host := range ipsetHosts {
		ipsetBasename := hostIpsetBasename(host)
		file.WriteString(fmt.Sprintf("ipset=/%s/ipv4.%s,ipv6.%s\n",
			host, ipsetBasename, ipsetBasename))
	}
	file.WriteString(fmt.Sprintf("pid-file=/run/dnsmasq.%s.pid\n",
		bridgeName))
	file.WriteString(fmt.Sprintf("interface=%s\n", bridgeName))
	isIPv6 := false
	if bridgeIPAddr != "" {
		ip := net.ParseIP(bridgeIPAddr)
		if ip == nil {
			log.Fatalf("createDnsmasqConfiglet failed to parse IP %s",
				bridgeIPAddr)
		}
		isIPv6 = (ip.To4() == nil)
		file.WriteString(fmt.Sprintf("listen-address=%s\n",
			bridgeIPAddr))
	} else {
		// XXX error if there is no bridgeIPAddr?
	}
	file.WriteString(fmt.Sprintf("hostsdir=%s\n", hostsDir))
	file.WriteString(fmt.Sprintf("dhcp-hostsdir=%s\n", dhcphostsDir))

	ipv4Netmask := "255.255.255.0" // Default unless there is a Subnet
	dhcpRange := bridgeIPAddr      // Default unless there is a DhcpRange

	// By default dnsmasq advertises a router (and we can have a
	// static router defined in the NetworkInstanceConfig).
	// To support airgap networks we interpret gateway=0.0.0.0
	// to not advertise ourselves as a router. Also,
	// if there is not an explicit dns server we skip
	// advertising that as well.
	advertizeRouter := true
	var router string

	if netstatus.Logicallabel == "" {
		log.Functionf("Internal switch without external port case, dnsmasq suppress router advertise\n")
		advertizeRouter = false
	} else if netstatus.Gateway != nil {
		if netstatus.Gateway.IsUnspecified() {
			advertizeRouter = false
		} else {
			router = netstatus.Gateway.String()
		}
	} else if bridgeIPAddr != "" {
		router = bridgeIPAddr
	} else {
		advertizeRouter = false
	}
	if netstatus.DomainName != "" {
		if isIPv6 {
			file.WriteString(fmt.Sprintf("dhcp-option=option:domain-search,%s\n",
				netstatus.DomainName))
		} else {
			file.WriteString(fmt.Sprintf("dhcp-option=option:domain-name,%s\n",
				netstatus.DomainName))
		}
	}
	advertizeDns := false
	if len(netstatus.DnsServers) > 0 {
		advertizeDns = true
		var addrList []string
		for _, srvIP := range netstatus.DnsServers {
			addrList = append(addrList, srvIP.String())
		}
		file.WriteString(fmt.Sprintf("dhcp-option=option:dns-server,%s\n",
			strings.Join(addrList, ",")))
	}
	if netstatus.NtpServer != nil {
		file.WriteString(fmt.Sprintf("dhcp-option=option:ntp-server,%s\n",
			netstatus.NtpServer.String()))
	} else {
		ntpStr := ""
		for _, s := range ntpServers {
			ntpStr += "," + s.String()
		}
		if len(ntpStr) != 0 {
			file.WriteString("dhcp-option=option:ntp-server" + ntpStr + "\n")
		}
	}
	if netstatus.Subnet.IP != nil {
		ipv4Netmask = net.IP(netstatus.Subnet.Mask).String()
	}
	if netstatus.Subnet.IP != nil {
		if advertizeRouter && !ctx.disableDHCPAllOnesNetMask {
			// Network prefix "255.255.255.255" will force packets to go through
			// dom0 virtual router that makes the packets pass through ACLs and flow log.
			file.WriteString(fmt.Sprintf("dhcp-option=option:netmask,%s\n",
				"255.255.255.255"))
		} else {
			file.WriteString(fmt.Sprintf("dhcp-option=option:netmask,%s\n",
				ipv4Netmask))
		}
	}
	if advertizeRouter {
		// IPv6 XXX needs to be handled in radvd
		if !isIPv6 {
			file.WriteString(fmt.Sprintf("dhcp-option=option:router,%s\n",
				router))
			if !ctx.disableDHCPAllOnesNetMask {
				file.WriteString(fmt.Sprintf("dhcp-option=option:classless-static-route,%s/32,%s,%s,%s,%s,%s\n",
					router, "0.0.0.0",
					"0.0.0.0/0", router,
					netstatus.Subnet.String(), router))
			}
		}
	} else {
		log.Functionf("createDnsmasqConfiglet: no router\n")
		if !isIPv6 {
			file.WriteString(fmt.Sprintf("dhcp-option=option:router\n"))
		}
		if !advertizeDns {
			// Handle isolated network by making sure
			// we are not a DNS server. Can be overridden
			// with the DnsServers above
			log.Functionf("createDnsmasqConfiglet: no DNS server\n")
			file.WriteString(fmt.Sprintf("dhcp-option=option:dns-server\n"))
		}
	}
	if netstatus.DhcpRange.Start != nil {
		dhcpRange = netstatus.DhcpRange.Start.String()
	}
	if isIPv6 {
		file.WriteString(fmt.Sprintf("dhcp-range=::,static,0,60m\n"))
	} else {
		file.WriteString(fmt.Sprintf("dhcp-range=%s,static,%s,60m\n",
			dhcpRange, ipv4Netmask))
	}
}

func addhostDnsmasq(bridgeName string, appMac string, appIPAddr string,
	hostname string) {

	log.Functionf("addhostDnsmasq(%s, %s, %s, %s)\n", bridgeName, appMac,
		appIPAddr, hostname)
	if dnsmasqStopStart {
		stopDnsmasq(bridgeName, true, false)
	}
	ip := net.ParseIP(appIPAddr)
	if ip == nil {
		log.Fatalf("addhostDnsmasq failed to parse IP %s", appIPAddr)
	}
	isIPv6 := (ip.To4() == nil)
	suffix := ".inet"
	if isIPv6 {
		suffix += "6"
	}

	dhcphostsDir := dnsmasqDhcpHostDir(bridgeName)
	ensureDir(dhcphostsDir)
	cfgPathname := dhcphostsDir + "/" + appMac + suffix

	file, err := os.Create(cfgPathname)
	if err != nil {
		log.Fatal("addhostDnsmasq failed ", err)
	}
	defer file.Close()
	if isIPv6 {
		file.WriteString(fmt.Sprintf("%s,[%s],%s\n",
			appMac, appIPAddr, hostname))
	} else {
		file.WriteString(fmt.Sprintf("%s,id:*,%s,%s\n",
			appMac, appIPAddr, hostname))
	}
	file.Close()
	if dnsmasqStopStart {
		startDnsmasq(bridgeName)
	}
}

func removehostDnsmasq(bridgeName string, appMac string, appIPAddr string) {

	log.Functionf("removehostDnsmasq(%s, %s, %s)\n",
		bridgeName, appMac, appIPAddr)
	stopDnsmasq(bridgeName, true, false)
	ip := net.ParseIP(appIPAddr)
	if ip == nil {
		log.Fatalf("removehostDnsmasq failed to parse IP %s", appIPAddr)
	}
	isIPv6 := (ip.To4() == nil)
	suffix := ".inet"
	if isIPv6 {
		suffix += "6"
	}

	dhcphostsDir := dnsmasqDhcpHostDir(bridgeName)
	ensureDir(dhcphostsDir)

	cfgPathname := dhcphostsDir + "/" + appMac + suffix
	if _, err := os.Stat(cfgPathname); err != nil {
		log.Functionf("removehostDnsmasq(%s, %s) failed: %s\n",
			bridgeName, appMac, err)
	} else {
		if err := os.Remove(cfgPathname); err != nil {
			errStr := fmt.Sprintf("removehostDnsmasq %v", err)
			log.Errorln(errStr)
		}
	}
	startDnsmasq(bridgeName)
}

func deleteDnsmasqConfiglet(bridgeName string) {

	log.Functionf("deleteDnsmasqConfiglet(%s)\n", bridgeName)
	cfgPathname := dnsmasqConfigPath(bridgeName)
	if _, err := os.Stat(cfgPathname); err == nil {
		if err := os.Remove(cfgPathname); err != nil {
			errStr := fmt.Sprintf("deleteDnsmasqConfiglet %v",
				err)
			log.Errorln(errStr)
		}
	}
	dhcphostsDir := dnsmasqDhcpHostDir(bridgeName)
	ensureDir(dhcphostsDir)
	if err := RemoveDirContent(dhcphostsDir); err != nil {
		errStr := fmt.Sprintf("deleteDnsmasqConfiglet %v", err)
		log.Errorln(errStr)
	}
}

func RemoveDirContent(dir string) error {
	files, err := ioutil.ReadDir(dir)
	if err != nil {
		return err
	}
	for _, file := range files {
		filename := dir + "/" + file.Name()
		log.Functionln("RemoveDirContent found ", filename)
		err = os.RemoveAll(filename)
		if err != nil {
			return err
		}
	}
	return nil
}

// Run this:
//
//	${DMDIR}/dnsmasq -b -C /run/zedrouter/dnsmasq.${BRIDGENAME}.conf
func startDnsmasq(bridgeName string) {

	log.Functionf("startDnsmasq(%s)\n", bridgeName)
	cfgPathname := dnsmasqConfigPath(bridgeName)
	name := "nohup"
	args := []string{
		"/opt/zededa/bin/dnsmasq",
		"-C",
		cfgPathname,
	}
	log.Functionf("Calling command %s %v\n", name, args)
	out, err := base.Exec(log, name, args...).CombinedOutput()
	if err != nil {
		log.Errorf("startDnsmasq: Failed starting dnsmasq for bridge %s (%s)",
			bridgeName, err)
	} else {
		log.Functionf("startDnsmasq: Started dnsmasq with output: %s", out)
	}
}

func stopDnsmasq(bridgeName string, printOnError bool, delConfiglet bool) {

	log.Functionf("stopDnsmasq(%s)\n", bridgeName)
	pidfile := fmt.Sprintf("/run/dnsmasq.%s.pid", bridgeName)
	pidByte, err := ioutil.ReadFile(pidfile)
	if err != nil {
		log.Errorf("stopDnsmasq: pid file read error %v\n", err)
		return
	}
	pidStr := string(pidByte)
	pidStr = strings.TrimSuffix(pidStr, "\n")
	pidStr = strings.TrimSpace(pidStr)
	pid, err := strconv.Atoi(pidStr)
	if err != nil {
		log.Errorf("stopDnsmasq: pid convert error %v\n", err)
		return
	}

	cfgFilename := dnsmasqConfigFile(bridgeName)
	utils.PkillArgs(log, cfgFilename, printOnError, false)

	startCheckTime := time.Now()
	// check and wait until the process is gone or maximum of 60 seconds is reached
	for {
		p, err := os.FindProcess(pid)
		if err == nil {
			err = p.Signal(syscall.Signal(0))
			if err != nil {
				log.Functionf("stopDnsmasq: kill process done for %d\n", pid)
				break
			} else {
				log.Functionf("stopDnsmasq: wait for %d to finish\n", pid)
			}
			if time.Since(startCheckTime).Seconds() > 60 {
				log.Errorf("stopDnsmasq: kill dnsmasq on %s pid %d not finish in 60 seconds\n", bridgeName, pid)
				break
			}
			time.Sleep(1 * time.Second)
		} else {
			log.Functionf("stopDnsmasq: find dnsmasq process %s error %v\n", pidStr, err)
			break
		}
	}

	err = os.Remove(pidfile)
	if err != nil && printOnError {
		log.Errorf("stopDnsmasq: remove pidfile %s error %v", pidfile, err)
	}

	if delConfiglet {
		deleteDnsmasqConfiglet(bridgeName)
	}
}

// checkAndPublishDhcpLeases needs to be called periodically since it
// refreshes the LastSeen and does garbage collection based on that timestamp
func checkAndPublishDhcpLeases(ctx *zedrouterContext) {
	changed := updateAllLeases(ctx)
	haveSwitch := haveSwitchNetworkInstances(ctx)
	if !changed && !haveSwitch {
		return
	}
	// Walk all and update all which gained or lost a lease
	pub := ctx.pubAppNetworkStatus
	items := pub.GetAll()
	for _, st := range items {
		changed := false
		status := st.(types.AppNetworkStatus)
		for i := range status.UnderlayNetworkList {
			ulStatus := &status.UnderlayNetworkList[i]
			var ipv4Assigned bool
			var leasedIPv4 net.IP
			var snoopedIPv6s []net.IP
			netconfig := lookupNetworkInstanceConfig(ctx,
				ulStatus.Network.String())
			if netconfig != nil && netconfig.Type == types.NetworkInstanceTypeSwitch {
				leasedIPv4, snoopedIPv6s, ipv4Assigned = lookupVifIPTrig(ctx, ulStatus.Mac)
				log.Functionf("found %t IPv4 %s, IPv6 %s for %s",
					ipv4Assigned, leasedIPv4.String(), snoopedIPv6s, ulStatus.Mac)
				if !ipListEqual(snoopedIPv6s, ulStatus.AllocatedIPv6List) {
					ipList := []string{}
					for _, ip := range snoopedIPv6s {
						ipList = append(ipList, ip.String())
					}
					ulStatus.AllocatedIPv6List = ipList
					changed = true
					continue
				}
			} else {
				l := findLease(ctx, status.Key(), ulStatus.Mac, true)
				ipv4Assigned = (l != nil)
				if ipv4Assigned {
					leasedIPv4 = net.ParseIP(l.IPAddr)
				}
				log.Functionf("found %t IP %s for %s",
					ipv4Assigned, leasedIPv4.String(), ulStatus.Mac)
			}
			assignedIP := net.ParseIP(ulStatus.AllocatedIPv4Addr)
			if ulStatus.IPv4Assigned != ipv4Assigned || assignedIP == nil || !assignedIP.Equal(leasedIPv4) {
				log.Functionf("Changing(%s) %s mac %s to %t",
					status.Key(), status.DisplayName,
					ulStatus.Mac, ipv4Assigned)
				ulStatus.IPv4Assigned = ipv4Assigned
				if !ipv4Assigned {
					ulStatus.IPAddrMisMatch = true
					changed = true
					continue
				}
				// Pick up from VIFIPTrig on change
				if ulStatus.AllocatedIPv4Addr == "" || assignedIP == nil ||
					(netconfig != nil && netconfig.Type == types.NetworkInstanceTypeSwitch && !assignedIP.Equal(leasedIPv4)) {
					ulStatus.IPAddrMisMatch = false
					if !isEmptyIP(leasedIPv4) {
						ulStatus.AllocatedIPv4Addr = leasedIPv4.String()
					}
					changed = true
					log.Noticef("Setting IP to %s",
						leasedIPv4.String())
					continue
				}
				if assignedIP != nil && !assignedIP.Equal(leasedIPv4) {
					log.Errorf("IP address mismatch found - App: %s, Mac: %s, Allocated IP: %s, Leased IP: %s",
						status.DisplayName, ulStatus.Mac, ulStatus.AllocatedIPv4Addr, leasedIPv4.String())
					ulStatus.IPAddrMisMatch = true
					// XXX Should we do the following at this point?
					// 1) Stop dnsmasq corresponding to this network instance
					// 2) Remove the leases file
					// 3) Start dnsmasq again.
					// App will get the correct IP address at least in the next DHCP cycle.
					// XXX Should we send the leased IP also as part of app status to cloud?
				} else {
					ulStatus.IPAddrMisMatch = false
				}
				changed = true
			}
		}
		if changed {
			publishAppNetworkStatus(ctx, &status)
		}
	}
}

func isEmptyIP(ip net.IP) bool {
	return ip == nil || ip.Equal(net.IP{})
}

func ipListEqual(one []net.IP, two []string) bool {
	if len(one) != len(two) {
		return false
	}
	for i := 0; i < len(one); i++ {
		if one[i].String() != two[i] {
			return false
		}
	}
	return true
}

// findLease returns a pointer so the caller can update the
// lease information
// Ignores a lease which has expired if ignoreExpired is set
func findLease(ctx *zedrouterContext, hostname string, mac string, ignoreExpired bool) *dnsmasqLease {
	for i := range ctx.dhcpLeases {
		l := &ctx.dhcpLeases[i]
		if l.Hostname != hostname {
			continue
		}
		if l.MacAddr != mac {
			continue
		}
		if ignoreExpired && l.LeaseTime.Before(time.Now()) {
			log.Warnf("Ignoring expired lease: %v", *l)
			return nil
		}
		log.Tracef("Found %v", *l)
		return l
	}
	log.Tracef("Not found %s/%s", hostname, mac)
	return nil
}

// addOrUpdateLease returns true if something changed
// XXX Assumes MAC addresses unique. take bridgename as argument to
// keep separate per bridge?
func addOrUpdateLease(ctx *zedrouterContext, lease dnsmasqLease) bool {
	l := findLease(ctx, lease.Hostname, lease.MacAddr, false)
	if l == nil {
		ctx.dhcpLeases = append(ctx.dhcpLeases, lease)
		log.Functionf("Adding lease %v", lease)
		return true
	} else if !cmp.Equal(*l, lease) {
		log.Functionf("Updating lease %v with %v", *l, lease)
		*l = lease
		return true
	} else {
		return false
	}
}

// markRemoveLease will fatal if the lease does not exist
// Merely marks for removal; see purgeRemovedLeases
func markRemoveLease(ctx *zedrouterContext, hostname string, mac string) {
	l := findLease(ctx, hostname, mac, false)
	if l == nil {
		log.Fatalf("Lease not found %s/%s", hostname, mac)
	}
	log.Functionf("Removing lease %v", l)
	l.Remove = true
}

// purgeRemovedLeases does the actual removal of the marked entries
func purgeRemovedLeases(ctx *zedrouterContext) {
	var newLeases []dnsmasqLease
	var removed = 0
	for _, lease := range ctx.dhcpLeases {
		if lease.Remove {
			removed++
			continue
		}
		newLeases = append(newLeases, lease)
	}
	ctx.dhcpLeases = newLeases
	log.Functionf("purgeRemovedLeases removed %d", removed)
	// XXX change to log.Tracef
	log.Functionf("XXX after purgeRemovedLeases %v", ctx.dhcpLeases)
}

type dnsmasqLease struct {
	BridgeName string
	LastSeen   time.Time // For garbage collection
	Remove     bool      // Marked for removal

	// From leases file
	LeaseTime time.Time
	MacAddr   string
	IPAddr    string
	Hostname  string
}

const leaseGCTime = 5 * time.Minute

// updateAllLeases maintains ctx.dhcpLeases. It reads all of the leases and
// adds new ones immediately. It removes an old old if it haven't seen in
// 30 seconds (this is to handle file truncation/rewrite by dnsmasq) This
// timer assumes the function is called very 10 seconds.
// Returns true if there was a change to at least one lease
func updateAllLeases(ctx *zedrouterContext) bool {
	changed := false
	bridgeNames := dnsmasqBridgeNames()
	log.Tracef("bridgeNames: %v", bridgeNames)
	for _, bridgeName := range bridgeNames {
		leases, err := readLeases(bridgeName)
		if err != nil {
			log.Warnf("readLeases(%s) failed: %s", bridgeName, err)
			continue
		}
		log.Tracef("read leases(%s) %v", bridgeName, leases)
		// Add any new ones
		for _, l := range leases {
			if addOrUpdateLease(ctx, l) {
				changed = true
			}
		}
	}
	// Look for any old leases
	// XXX time limit is 5 minutes and we are assuming we get called
	// every 10 seconds or so.
	removed := false
	for _, l := range ctx.dhcpLeases {
		if time.Since(l.LastSeen) <= leaseGCTime ||
			time.Since(l.LeaseTime) <= leaseGCTime {
			continue
		}
		log.Functionf("lease %v garbage collected: lastSeen %v ago, lease expiry %v ago",
			l, time.Since(l.LastSeen), time.Since(l.LeaseTime))
		markRemoveLease(ctx, l.Hostname, l.MacAddr)
		changed = true
		removed = true
	}
	if removed {
		purgeRemovedLeases(ctx)
	}
	return changed
}

// readLeases returns a slice of structs with mac, IP, uuid
// XXX Do we need to handle file which is deleted when bridge/networkinstance is deleted?
//
// Example content of leasesFile
// 1560664900 00:16:3e:00:01:01 10.1.0.3 63120af3-42c4-4d84-9faf-de0582d496c2 *
func readLeases(bridgeName string) ([]dnsmasqLease, error) {

	var leases []dnsmasqLease
	leasesFile := dnsmasqLeasePath(bridgeName)
	info, err := os.Stat(leasesFile)
	if err != nil {
		return leases, err
	}
	fileDesc, err := os.Open(leasesFile)
	if err != nil {
		return leases, err
	}
	reader := bufio.NewReader(fileDesc)
	for {
		line, err := reader.ReadString('\n')
		if err != nil {
			if err != io.EOF {
				log.Errorln("ReadString ", err)
				return leases, err
			}
			break
		}
		// remove trailing "/n" from line
		line = line[0 : len(line)-1]

		// Should have 5 space-separated fields. We only use 4.
		tokens := strings.Split(line, " ")
		if len(tokens) < 4 {
			log.Errorf("Less than 4 fields in leases file: %v",
				tokens)
			continue
		}
		i, err := strconv.ParseInt(tokens[0], 10, 64)
		if err != nil {
			log.Errorf("Bad unix time %s: %s", tokens[0], err)
			i = 0
		}
		lease := dnsmasqLease{
			BridgeName: bridgeName,
			LastSeen:   info.ModTime(),
			LeaseTime:  time.Unix(i, 0),
			MacAddr:    tokens[1],
			IPAddr:     tokens[2],
			Hostname:   tokens[3],
		}
		leases = append(leases, lease)
	}
	return leases, nil
}

// lookupVifIPTrig returns the IP address for the MAC address
// XXX Assumes MAC addresses unique. take bridgename as argument to
// XXX No subscribers. Use local map from (bridgename, mac) to IP? Used by
// flowstats goroutine hence  would need lock.
func lookupVifIPTrig(ctx *zedrouterContext, mac string) (net.IP, []net.IP, bool) {
	pub := ctx.pubAppVifIPTrig
	st, _ := pub.Get(mac)
	if st == nil {
		return net.IP{}, []net.IP{}, false
	}
	vifTrig := st.(types.VifIPTrig)
	ipv4Up := !isEmptyIP(vifTrig.IPv4Addr)
	return vifTrig.IPv4Addr, vifTrig.IPv6Addrs, ipv4Up
}

// When we restart dnsmasq with smaller changes like changing DNS server
// file configuration, we should not delete the hosts configuration for
// that has the IP address allotment information.
func deleteOnlyDnsmasqConfiglet(bridgeName string) {

	log.Functionf("deleteOnlyDnsmasqConfiglet(%s)\n", bridgeName)
	cfgPathname := dnsmasqConfigPath(bridgeName)
	if _, err := os.Stat(cfgPathname); err == nil {
		if err := os.Remove(cfgPathname); err != nil {
			errStr := fmt.Sprintf("deleteOnlyDnsmasqConfiglet %v",
				err)
			log.Errorln(errStr)
		}
	}
}
